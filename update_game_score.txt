async updateGameScore(gameId: number, team1Score: number, team2Score: number): Promise<Game> {
    console.log(`Updating game ${gameId} with scores: ${team1Score}-${team2Score} and setting state to final`);
    
    // First get current game and active game set
    const [game] = await db.select().from(games).where(eq(games.id, gameId));
    if (!game) {
      throw new Error(`Game ${gameId} not found`);
    }

    const activeGameSet = await this.getActiveGameSet();
    if (!activeGameSet) {
      throw new Error('No active game set found');
    }

    // Log all active checkins before update
    const activeCheckins = await db
      .select({
        id: checkins.id,
        userId: checkins.userId,
        username: users.username,
        isActive: checkins.isActive
      })
      .from(checkins)
      .innerJoin(users, eq(checkins.userId, users.id))
      .where(eq(checkins.gameId, gameId));

    console.log(`Found ${activeCheckins.length} checkins for game ${gameId} before deactivation:`,
      activeCheckins.map(c => `${c.username} (Active: ${c.isActive})`));

    // Update the game with scores and set state to final
    const [updatedGame] = await db
      .update(games)
      .set({
        team1Score,
        team2Score,
        state: 'final', // Change state to final
        endTime: getCentralTime() // Add end time
      })
      .where(eq(games.id, gameId))
      .returning();
      
    // Determine promotion type and team
    const promotionInfo = await this.determinePromotionType(gameId);
    console.log('Promotion info for game', gameId, ':', promotionInfo);

    // Get all players from this game
    const gamePlayerIds = await db
      .select({
        userId: gamePlayers.userId
      })
      .from(gamePlayers)
      .where(eq(gamePlayers.gameId, gameId));

    // Initialize promotedPlayers outside the if block
    let promotedPlayers: { userId: number; team: number }[] = [];

    if (promotionInfo) {
      // Rest of the promotion logic...
      // Process promotions and update checkins
      // ...
      
      // [Code for promotion handling remains unchanged]
      // ...
    }
    
    // Deactivate ALL checkins for this game
    await db
      .update(checkins)
      .set({ isActive: false })
      .where(eq(checkins.gameId, gameId));
      
    console.log(`Deactivated all checkins for game ${gameId}`);
    
    // [Rest of auto-up and duplicate handling code remains unchanged]
    // ...

    // IMPORTANT: Calculate the correct queue position at the end of the method
    // Count completed games including the one we just finished
    const [completedGamesCount] = await db
      .select({ count: sql`COUNT(*)` })
      .from(games)
      .where(
        and(
          eq(games.setId, activeGameSet.id),
          eq(games.state, 'final') // Count only finished games
        )
      );
    
    // Calculate what the queue positions should be based on number of completed games
    // Formula: playersPerTeam * 2 * number_of_games + 1
    const gamesFinished = Number(completedGamesCount?.count || 0);
    const correctQueuePosition = (activeGameSet.playersPerTeam * 2 * gamesFinished) + 1;
    const correctNextUpPosition = correctQueuePosition + (activeGameSet.playersPerTeam * 2);
    
    console.log(`Game ${gameId} finished. Total games completed: ${gamesFinished}.`);
    console.log(`Queue position calculation:`, {
      playersPerTeam: activeGameSet.playersPerTeam,
      gamesFinished,
      formula: `(${activeGameSet.playersPerTeam} * 2 * ${gamesFinished}) + 1 = ${correctQueuePosition}`
    });
    console.log(`Setting current_queue_position to ${correctQueuePosition} and queue_next_up to ${correctNextUpPosition}`);
    
    // Update the game set with corrected queue positions
    await db
      .update(gameSets)
      .set({ 
        currentQueuePosition: correctQueuePosition,
        queueNextUp: correctNextUpPosition
      })
      .where(eq(gameSets.id, activeGameSet.id));
    
    // Make sure all loss_promoted and win_promoted players are marked isActive=true
    // This fixes the issue where they don't show up in the NEXT_UP list
    await db
      .update(checkins)
      .set({ isActive: true })
      .where(
        and(
          inArray(checkins.type, ['loss_promoted', 'win_promoted']),
          eq(checkins.isActive, false),
          isNull(checkins.gameId),
          eq(checkins.gameSetId, activeGameSet.id)
        )
      );

    // Log the players we just updated
    const updatedPlayers = await db
      .select({
        id: checkins.id,
        username: users.username,
        type: checkins.type,
        queuePosition: checkins.queuePosition
      })
      .from(checkins)
      .innerJoin(users, eq(checkins.userId, users.id))
      .where(
        and(
          inArray(checkins.type, ['loss_promoted', 'win_promoted']),
          eq(checkins.isActive, true),
          isNull(checkins.gameId),
          eq(checkins.gameSetId, activeGameSet.id)
        )
      );
    
    if (updatedPlayers.length > 0) {
      console.log(`Updated ${updatedPlayers.length} promoted players to isActive=true:`, 
        updatedPlayers.map(p => `${p.username} (Type: ${p.type}, Position: ${p.queuePosition})`));
    }

    console.log(`Game ${gameId} updated successfully:`, updatedGame);
    return updatedGame;
  }
